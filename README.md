# 임동욱 학번202330127
### 6월 14일 강의
## 자바의 입출력 스트림
입력스트림: 입력장치로부터 자바 프로그램으로 데이터를 전달하는 객체  
출력스트림: 자바 프로그램에서 출력 장치로 데이터를 보내는 객체  
특징  
-입출력 스트림 기본단위: 바이트  
-단방향스트림, 선입선출 구조
## 문자스트림
-문자만 입출력하는 스트림  
-문자가 아닌 바이너리 데이터는 스트림에서 처리하지 못함  
-문자가 아닌 데이터를 문자 스트림으로 출력하면 깨진 기호가 출력
## 바이트 스트림
-입출력 데이터를 단순 바이트의 흐름으로 처리
## 스트림 연결
여러개의 스트림을 연결하여 사용할수 있음
## 문자 스트림으로 텍스트파일 읽기
1. 파일 입력스트림 생성(파일읽기)  
- 스트림을 생성하고 파일열어 스트림과 연결  
2. 파일 읽기
- read()로 문자 하나씩 파일에서 읽는다  
3. 스트림 닫기  
- 스트림이 더이상 필요 없으면 닫앙함
- close()로 스트림 닫기
## 문자 스트림으로 텍스트파일 쓰기
텍스트 파일에 쓰기위해 문자 스트림 FileWriter 클래스 이용  
1. 파일 출력 스트림 생성(파일 열기)  
- 스트림을 생성하고 파일을 열어 스트림과 연결  
2. 파일쓰기  
- write()로 문자하나씩 파일에 기록  
- 블록단위로 쓰기 가능  
3. 스트림 닫기  
- close()로 스트림닫기
## file 클래스
- 파일의 경로명 및 속성을 다루는 클래스
- 파일 이름 변경, 삭제, 디렉터리, 크기 등 파일 관리
- File 객체에는 파일 읽기/쓰기 기능 없음
## TCP/IP
두 시스템 간에 데이터가 손상없이 안전하게 전송되도록 하는 통신 프로그램  
-TCP에서 동작하는 응용 프로그램  
- email, FTP, 웹(http)등
## IP주소
-네트워크상에서 유일하게 식별될수 있는 컴퓨터 주소  
- 숫자로 구성된 주소  
- 4개의 숫자가 .으로 연결  
-숫자로된 주소는 기억하기 어려움으로 www.naver.com과 같은 문자열로 구성된 도메인이름으로 바꿔사용  
- DNS(Domain Network System)  
-현제는 32비트의 IP버전 4(IPv4)가 사용되고 있음  
- IP주소 고갈로 인해 128비트의 IP버전(IPv6)이 점점 사용되는 추세  
-자신의 IP주소를 간단히 localhost라는 이름으로 사용가능
## 포트
통신하는 프로그램 같에 가상의 연결된 포트 생성  
-IP주소는 네트워크 상의 컴퓨터 또는 시스템을 식별하는 주소  
-포트 번호 번호를 이용하여 통신할 응용프로그램 식별  
모든 응용프로그램은 하나 이상의 포트 생성가능  
-포트를 이용해 상대방 응용프로그램과 데이터 교환  
## 소켓
-TCP/IP 네트워크를 이용해 쉽게 통신 프로그램을 작성하도록 하는 기반 기술  
소켓  
- 두 응용프로그램 간의 양방향 통신 링크의 한쪽 끝 단  
- 소켓끼리 경우의 수를 주고받음  
- 소켓은 특정 IP포트 벝호와 결합  
-자바로 소켓 통신할수 있는 라이브러리 지원  
-소켓 종류: 서버 소켓, 클라이언트 소켓
## 소켓 클래스
클라이언트 소켓에 사용되는 클래스  
java.net 패키지에 포함  
## 서버에 클라이언트가 연결되는 과정
1. 서버는 서버 소켓으로 들어오는 연결 요청을 기다림  
2. 클라이언트가 서버에게 연결 요청  
3. 서버가 연결 요청 수락  
- 새로운 클라이언트 소켓을 만들어 다른 클라이언트 소켓과 통신하게함
### 6월7일 강의
## 스윙의 페인팅 기본
모든 컴포넌트는 자신의 모양을 스스로 그린다  
컨테이너는 자신을 그린후 그위에 잣기 컴포넌트들에게 그리기 지시  
모든 스윙컴포넌트는 자신의 모양을 그리는 paintComponent()메소드 보유
## 그래픽 기반 GUI 프로그래밍
스윙컴포넌트에 의존하지 않고 선, 원, 이미지 등을이용하여 직접 화면을 구성하는 방법  
그래픽 기반 GUI프로그래밍의 학습이 필요한이유  
-컴포넌트의 한계를 극복하고 차트, 게임등 자유로운 컨텐츠 표현  
-그래픽은 컴포넌트에 비해 화면 출력속도가 빠름  
-그래픽을 이용해 자신만의 컴포넌트 개발
## JLabel을 이용한 이미지 그리기
장점: 이미지 그리기 간편하다  
단점: 이미지의 원본 크기대로 그리므로 이미지 크기 조절 불가
## Graphics의 drawImage()로 이미지 출력
장점: 이미지 일부분 등 이미지의 원본 크기와 다르게 그리기 가능  
단점: 컴포넌트로 관리할수 없음 이미지의 위치나 크기등을 적절히 조정하는 코딩 필요
## repaint
모든 컴포넌트가 가지고 있는 메소드  
자바 플랫폼에게 컴포넌트 그리기를 강제지시하는 매소드  
repaint()를 호출하면 자바 플래폼이 컴포넌트의 paintComponent()호출
## 스레드
운영체제에서 관리되는 하나의 작업  
스레드와 테스크(작업)는 바꾸어 사용해도 무관
## 멀티스레드
여러 스레드를 동시에 실행시키는 응용프로그램을 작성하는 기법  
## 스레드 구성
스레드 코드  
-작업을 싱행하기 위해 작성한 프로그램 코드  
-개발자가 작성 
## 멀티 프로세싱
-하나의 응용 프로그램이 여러개의 프로세스를 생성하고 각 프로세스가 하나의 작업을 처리하는 기법  
-각 프로세스 독립된 메모리영역을 보유하고 실행  
-프로세스 사이의 문맥 교환에 따른 과도한 오버헤드와 시간소모의 문제점
## 멀티 스레딩
-하나의 응용프로그램이 여러개의 스레드를 생성하고 각 스레드가 하나의 작업을 처리하는 기법  
-하나의 응용프로그램에 속한 스레드는 변수 메모리, 파일오픈 테이블 등 자원으로 공유하므로 문맥교환에 따른 오버헤드가 매우 적음
## 자바 스레드
자바 가상기계에 의해 스케쥴되는 실행단위의 코드 블럭  
스레드의 생명주기는 JVM에 의해 관리됨: JVM은 스레드 단위로 스케쥴링
## JVM과 자바의 멀티스레딩
하나의 JVM은 하나의 자바 응용프로그램만 실행  
-자바 응용 프로그램이 시작될때 JVM이 함께 실행  
-자바 응용 프로그램이 종료될떄 JVM도 함께 종료  
응용프로그램은 하나 이상의 스레드로 구성 가능
## 스레드를 상속 받아 run()으로 오버라이딩
스레드 클래스 상속받아 새 클래스 작성  
run()메소드 작성  
-run()메소드를 스레드 코드라고 부름  
-run()메소드에서 스레드 실행 시작
## 스레드 시작  
start()메소드 사용  
-스레드 작동시작  
-스레드 객체의 run()이 비로소 실행
## Runnable 인터페이스 구현하는 새 클래스 작성  
run() 메소드 구현  
-run()메소드를 스레드 코드라 부름  
-run()메소드에서 스레드 실행 시작
## main스레드
JVM이 응용프로그램을 실행할때 디폴트로 생성되는 스레드  
## 스레드 종료와 타스레드 강제종료
스스로 종료  
-run() 메소드 리턴  
타 스레드에서 강제 종료  
-interrupt() 메소드 사용
## 스레드 동기화
멀티 스레드 프로그램 작성시 주의점  
-다수의 스레드가 공유 데이터에 동시에 접근하는 경우  
- 공유데이터의 값에 예상치 못한 결과 발생가능  
스레드 동기화  

-동기화란?  
- 스레드 사이의 실행순서 제어, 공유 데이터에 대한 접근을 원활하게 하는 기법  

-멀티 스레드의 공유 데이터의 동시 접근 문제 해결  
- 방법1: 공유데이터로 접근하는 모든 스레드의 한줄 세우기  
- 방법2: 한 스레드가 공유 데이터에 대한 적업을 끝날때까지 다른 스레득 대기하도록 함  

-자바의 스레드 동기화 방법 2가지  
- synchronized 키워드로 동기화 블록지정  
- wait()-notify() 메소드로 스레드의 실행 순서제어
## synchronized 블록지정
스레드가 독점적으로 실행해야 하는 부분(동기화코드)을 표시하는 키워드  
-임계 영역(critical section)표기 키워드
synchronizeed 블록 지정방법  
-메소드 전체 혹은 코드 블록  
## wait()-notify()를 이용한 스레드 동기화
wait()-notify()가 필요한 경우  
-공유 데이터로 두개 이상의 스레드가 데이터를 주고 받을때  
동기화 메소드  
-wait(): 다른 스레드가 notify()를 불러줄때까지 기다린다  
-notify():wait()를 호출하여 대기중인 스레드를 깨운다
- wait(),notify()는 Object의 메소드
###  5월 31일 강의
## 자바의 GUI 프로그래밍 방법
컴포넌트 기반 GUI 프로그래밍  
-스윙컴포넌트를 이용하여 쉽게 GUI를 구축  
-자바에서 제공하는 컴포넌트의 한계를 벗어나지 못함
## 스윙 컴포넌트의 공통메소드, Jcomponet의 메소드
JComponent  
스윙 컴포넌트는 모두 상속 받는 슈퍼 클래스, 추상클래스  
스윙 컴포넌트들이 상속 받는 공통 메소드와 상수 구현  
## JLabel의 용도
문자열이나 이미지를 화면에 출력하기 위함
## 레이블 생성 예시
-문자열 레이블 생성
```
JLabel textLabel = new JLabel("안녕하세요")
```
-이미지 레이블 생성  
이미지 파일로부터 이미지를 읽기 위해 imagelcon 클래스 사용
## JButton
버튼 모양의 컴포넌트, 사용자로부터 명령을 입력 받기 위한 목적  
## 이미지 버튼 만들기
하나의 버튼에 3개의 이미지 등록  
-마우스 조작에 따라 3개의 이미지 중 적절한 이미지 자동 출력  
## Item 이벤트
체크박스의 선택 상태에 변화가 생기떄 발생하는 이벤트  
이벤트가 발생하면 itemEvent 객체 생성  
ItemListener 리스너를 이용하여 이벤트 처리
## JRadioButton의 용도
버튼 그룹을 형성하고 그룹에 속한 버튼중 하나만 선택되는 라디오 버튼  
체크박스와의 차이점  
## 라디오 버튼 생성 및 Item이벤트 처리
라디오 버튼에 Item 이벤트 처리: ItemListener 리스너 이용  
라디오 버튼이 선택/해제되어 상태가 달라지면 , Item 이벤트 생성
## JTextField
한줄의 문자열을 입력받는창  
-텍스트 입력도중 <Enter>키가 입력되면 Action이벤트 발생  
-입력 가능한 문자개수와 입력창의 크기는 서로다름
## JTextArea
여러주의 문자열을 입력 받을수 있는창  
-스크롤 바를 지원하지 않는다
## JList<E>
하나이상의 아이템을 보여주고 아이템을 선택하도록 하는 리스트
## JComboBox<E>
텍스트 필드와 버튼, 드롭다운 리스트로 구성되는 콤보박스  
드롭다운 리스트에서 선택하는 것이 텍스트필드에 나타남
## 메뉴 구성
메뉴 만들기에 필요한 스우이 컴포넌트  
## 메뉴아이템을 클릭하면 Action 발생
메뉴 아이템은 사용자로부터의 지시나 명령을 받는데 사용  
각메뉴 아이템 마다 이벤트 리스너 설정
## 팝업 다이얼로그
사용자에게 메세지를 전달하거나 문자열을 간단히 입력받는 용도
## 확인 다이얼로그
사용자로부터 예/아니오 응답을 입력받는 다이얼로그
## 메세지 다이얼 로그
단순 메세지를 출력하는 다이얼로그
### 5월 24일 강의
## 9장
## 이벤트 기반 프로그래밍
-이벤트 발생에 의해 프로그램 흐름이 결정되는방식  
실행될 코드는 이벤트의 발생에 의해 전적으로 결정
-반대되는 개념: 배치 실행  
프로그램의 개발자가 프로그램의 흐름을 결정하는 방식  
-이벤트 기반 응용 프로그램의 구조  
각 이벤트 마다 처리하는 리스너 코드 보유
## 이벤트 처리 과정
1. 이벤트 발생  
2. 이벤트 객체 생성  
3. 응용프로그램에 작성된 이벤트 리스너 찾기  
4. 이벤트 리스너 실행
## 이벤트 객체
발생한 이벤트에 관한 정보를 가진 객체  
이벤트 리스너에 전달됨
## 이벤트 객체가 포함되는 정보
이벤트 종류와 이벤트 소스  
이벤트가 발생한 화면 좌표 및 컴포넌트 내 좌표  
이벤트가 발생한 버튼이나 메뉴 아이템의 문자열  
클릭된 마우스 버튼 번호 및 마우스의 클릭 횟수  
체크박스,라디오 버튼 등과 같은 컴포넌트에 이벤트가 발생했다면 체크 상태
## 이벤트 소스를 알아내는 메소드
Object getSource()
## 리스너 인터페이스
-이벤트 리스너  
이벤트를 처리하는 자바 프로그램 코드, 클래스로 작성  
-자바는 다양한 리스너 인터페이스 제공  
사용자의 이벤트 리스너 작성  
-자바의 리스너 인터페이스를 상속받아 구현  
-리스너 인터페이스의 모든 추상 메소드 구현
## 이벤트 리스너 작성 과정 사례
1. 이벤트와 이벤트 리스너 선택  
-버튼 크릭을 처리하고자 하는 경우  
2. 이벤트 리스너 클래스 작성 : ActionListener 인터페이스 구현  
3. 이벤트 리스너 등록  
-이벤트를 받아 처리하고자 하는 컴포넌트에 이벤트 리스너 등록  
-componenet.add(    )Listener
## 이벤트 리스너 작성방법  
독립 클래스로 작성  
-이벤트 리스너를 완전한 클래서로 작성  
-이벤트 리스너를 여러 곳에서 사용할때 적합  
내부 클래스(inner class)로 작성  
-클래스 안에 멤버처럼 클래스 작성  
-이벤트 리스너를 특정 클래스에서만 사용할때 적합  
익명 클래스(anonymous class)로 작성  
-클래스의 이름없이 간단히 리스너 작성  
-클래스 조차 만들필요 없이 리스너 코드가 간단한 경우에 적합
## 익명 클래스로 이벤트 리스너 작성
익명 클래스: 이름 없는 클래스  
-클래스 선언 + 인스턴스 생성을 한번에 달성  
간단한 리스너의 경우 익명 클래스 사용 추천  
-메소드의 개수가 1,2개인 리스너(ActionListener, ItemListener)에 대해 주로 사용
## 어뎁터 클래스
이벤트 리스너 구현에 따른 부담  
추상메소드가 하나뿐인 리스너는 어뎁터가 없다
## key 이벤트와 포커스
키 입력시, 다음 세 경우 각각 key 이벤트 발생  
-키를 누르는 순간  
-누른키를 때는 순간  
-누른 키를 떄는 순간(Unicode 키의 경우에만)
키 이벤트를 받을수 있는 조건  
-모든 컴포넌트  
-현제 포커스를 가진 커포넌트가 키 이벤트 독점  
## keyListener
응용프로그램에서 keListener를 상속받아 키 리스너 구현  
keyListener 3개 메소드  
컴포넌트에 키 이벤트 리스너 달기
## 유니코드 키
국제 산업 표준  
전 세계의 문자를 컴퓨터에서 일관되게 표현하기 위한 코드 체계  
문자들에 대해서만 키 코드 값 정의  
-A~Z,a~z,0~9,!,@ 등  
문자가 아닌 경우에는 표준화된 키 코드 값 없음
## keyEvent 객체
입력된 키 정보를 가진 이벤트 객체  
KeyEvent 개개체의 메소드로 입력된 키 판별
## KeyEvent 객체의 메소드로 입력된 키 판별
char KeyEvent.getKeyChar()  
-키의 유니코드 문자 값 변환  
-유니코드 문자키인 경우에만 의미 있음
## 가상키
카상키는 KeyEvent클래스에 실수로 선언
## Mouse 이벤트
사용자의 마우스 조작에 따라 발생하는 이벤트
### 5월 17일 강의
## 배치관리자 유형 4가지
-FlowLayout  
삽입되는 순서로 왼쪽에서 오른쪽으로 배치  
-BorderLayout  
동, 서, 남,북, 중앙의 5가지 영역으로 배치  
-GridLayout  
프로그램에서 설정한 동일한 크기로 2차원 격자로 나눔  
-CardLayout  
공간에 카드를 쌓아 놓은듯이 컴포넌트를 포개어 배치
## 컨테이너의 디폴트 배치과리자
컨테이너 생성시 자동으로 생성되는 배치관리자
## 컨테이너에 새로운 배치관리자 설정
-setLayout(LayoutManager lm)매소드 호출  
lm을 새로운 배치 관리자로 설정
## BorderLayout 생성자
생성자  
-BorderLayout()  
-BorderLayout(int hGap, int vGap)  
1. hGap: 좌우 두 컴포넌트 사이의 수평간격,픽셀단위(디폴트:0)  
2. vGap: 상하 두 컴포넌트 사이의 수평간격,픽셀단위(디폴트:0)
## GridLayout
컨테이너 공간을 동일한 사각형 격자로 분할하고 각 셀에 컴포넌트 하나씩 배치  
-생성자에 행수와 열수 지정  
-셀 왼쪽에서 오른쪽으로 다시 윙서 아래로 순서대로 배치
## GridLayout 생성자
GridLayout(int rows, int cols, int hGap, int vGap)  
rows:격자의 행수(디폴트:1)
cols:격자의 열수(디폴트:1)
hGap:좌우 두 컴포넌트 사이의 수평 간격, 픽셀단위(디폴트:0)
vGap:상하 두 컴포넌트 사이의 수직 간격, 픽셀단위(디폴트:0)
rows X cols 만큼의 셀을 가진 격자로 컨테이너 공간을 분할
## 배치관리자 없는 컨테이너
응용프로그램에서 직접 컨테이너가 필요한경우  
1. 컴포넌트의 크기나 위치를 개발자 임의로 결정하고자 하는 경우  
2. 게임 프로그램과 같이 시간이나 마우스/키보드의 입력에 따라 컴포넌트 들의 위치와 크기가 수시로 변하는 경우  
3. 여러 컴포넌트들이 서로 겹쳐 출력하고자 하는경우  
## 컴포넌트의 절대 위치와 크기 설정
배치관리자가 엇는 컨테이너에 컴포넌트를 삽입할때  
-프로그램에서 컴포넌트의 절대크기와 위치 설정  
-컴포넌트들이 서로 겹치게 할수 있음  
### 5월3일 강의
## 7장
## 컬렉션
요소라고 불리는 가변개수의 객체들의 저장소  
-객체들의 컨테이너로 불림  
-개수에 따라 크기 자동조절  
-요소의 삽입 삭제에 따른 요소의 위치가 다름  
고정크기의 배열을 다루는 어려움 해소  
다양한 객체들의 삽입,삭제, 검색등의 관리 용이
## 컬렉션의 특징
컬렉션은 제네릭 기법으로 구현  
1. 제네릭  
-클래스나 인터페이스 이름에 E, K, V 등 타입 매개변수 포함  
-제네릭 컬렉션 사례: 백터 Vector<E>
2. 컬렉션의 요소는 객체만 가능  
int char double 등의 기본 타입으록 구체화 불가
## 제네릭
클래스나 메소드를 형판에서 찍어내듯 생산할수 있도록 형판을 만드는 기법
## 백터의 특성
-<E>에 사용할 요소의 특정 타입 구체화  
-배열을 가변크기로 다룰수 있게 하는 컨테이너  
1. 배열의 길이 제한 극복  
2. 요소의 개수가 넘치면 자동으로 길이 조절  
-요소 객체들을 삽입, 삭제 검색하는 컨테이너  
1. 삽입 삭제에 따라 자동으로 요소의 위치 조정  
-Vector에 삽입 가능한 것  
1. 기본타입의 값은 와퍼(Wrapper) 객체로 만들어 저장  
-Vector에 객체 삽입   
1. 벡터의 맨뒤, 중간에 삽입 가능  
-Vector에서 객체삭제
1. 임의의 위치에 있는객체 삭제 가능
## ArrayList<E>
가변 크기 배열을 구현한 클래스 
-<E>에 요소로 사용할 특정 타입으로 구체화   
벡터와 거의 동일
-요소 삽입,삭제, 검색 등 벡터 기능과 거의 동일  
-벡터와 달리 스레드 기능 없음
## Iterator<E> 인터페이스
리스트 구조의 컬렉션에서 요소의 순차검색을 위한 인터페이스
## Iteractor 객체 걷어내기
컬렉션의 iteractor()메소드 호출  
-해당 컬렉션을 순차 검색할수 있는 Iterator객체 리턴
## HashMap<k,v>
키와 값의 쌍으로 구성되는 요소를 다루는 컬렉션  
-K:키로 사용할 요소의 타입  
-V:값으로 사용할 요소의 타입  
삽입 및 검색이 빠른 특징  
## 제네릭 만들기
클래스 이름 옆에 일반화된 타입 매개 변수 추가  
제네릭 개체 생성 및 활용  
-제네릭 타입에 구체적인 타입을 지정하여 객체를 생성하는 것을 구체화 하려함

### 8장
## GUI
사용자가 편리하게 입출력 할수 있도록 그래픽으로 화면을 구성하고 마우스나 키보드로 입력받을수 있도록 지원하는 자동화 인터페이스  
## Swing 패키지
AWT 기술을 기반으로 작성된 자바 라이브러리  
모든 AWT기능+추가된 풍부하고 화려한 고급 컴포넌트  
AWT 컴포넌트를 모두 스윙으로 재작성, AWT컴포넌트 이름 앞에 J자를 덧붙임  
순수자바 언어로 구현  
현재 자바의 GUI로 사용됨
## 컨테이너
다른 컴포넌트를 포함할수 있는 GUI 컴포넌트  
다른 컨테이너에 포함 될수 있음
## 컴포넌트 
컨테이너에 포함되야만 화면에 출력될수 있는 GUI개채  
다른 컴포넌트를 포함 할수 없는 순수 컴포넌트  
모든 GUI 컴포넌트가 상속 받는 클래스: java.awt.Component  
스윙 컴포넌트가 상속받는 클래스:javax.swing.JComponent
## 최상위 컴포넌트
다른 컨테이너에 포함되지 않고도 화면에 출력되며 독립적으로 존재 가능한 컨테이너
## 스윙 GUI 프로그램 만들기
스윙 GUI프로그램을 만드는 과정  
1. 스윙 프래임 만들기  
2. main() 메소드 작성  
3. 스윙프레임에 스윙 컴포넌트 붙이기
## 스윙 프레임
모든 스윙 컴포넌트를 담는 최상위 컨테이너  
-Jframe을 상속받아 구현  
-컴포넌트들은 화면에 보이려면 스윙프레임에 부착되야함  
스윙프레임의 기본구성  
-프레임:스윙 프로그램의 기본 틀  
-메뉴바: 메뉴들이 부착되는 공간  
-컨텐트팬: GUI 컴포넌트들이 부착되는 공간
## 스윙 응용 프로그램에서 main()의 기능과 위치
스윙프로그램에서 main()의 기능 최소화가 바람직  
-스윙 응용프로그램이 실행되는 시작점으로서의 기능만  
-스윙 프레임을 생성하는 정보와 코드로 최소화
## 컨텐츠팬에 컴포넌트 달기
컨텐츠팬이란?  
-스윙컴포넌트 들이 부착되는공간  
컨텐츠팬 알아내기  
-스윙 프레임에 붙은 디폴트 컨탠츠팬 알아내기  
컨텐츠팬에 컴포넌트 붙이기  
컨텐츠팬 변경

## 4월 19일 강의
## 추상 클래스의 인스턴스 생성 불가
추상 클래스는 온전치 않기에 객체 생성 불가
## 추상 클래스의 상속
추상 클래스를 상속 받으면 추상 클래스가 됨  
서브 클래스도 abstract로 선언 해야됨
## 추상클래스의 구현
서브 클래스에서 슈퍼 클래스의 추상 메소드 구현(오버라이딩)  
추상 클래스를 구현한 서브 클래스는 추상 클래스가 아님
## 추상 클래스의 목적
상속을 위한 슈퍼 클래스로 활용하는것  
서브 클래스에서 추상 메소드 구현  
다형성 실현
## 자바의 인터페이스
클래스가 구현해야할 메소드 들이 선언되는 추상형  
인터페이스 선언
## 자바 인터페이스에 대한 변화
자바7까지  
-인터페이스는 상수와 추상 메소드로만 구성  
자바8부터  
-상수와 추상 메소드 포함  
-default 메소드 포함  
-private 메소드 포함  
-static 메소드 포함  
여전히 인터페이스에는 필드(멤버 변수) 선언 불가
## 자바 인터페이스의 특징
자바 인터페이스 객체 생성 불가 
## 인터페이스 상속
인터페이스를 상속하여 확장된 인터페이스 작성 가능  
extends 키워드로 상속 선언  
인터페이스 다중 상속 허용
### 6장
## 패키지 개념과 필요성
ex 3명이 분담하여 자바 응용프로그램을 개발한느 경우 동일한 이름의 클래스가 존재할 가능성 있음  
->합칠떄 오류발생 가능성  
->개발자가 서로 다른 디랙토리로 코드 관리하여 해결
## 자바 패키지
서로 다른 클래스와 인터페이스를 컴파일한 클래스 파일들을 묶어놓은 디렉토리  
하나의 응용 프로그램은 한개 이상의 패키지로 작성  
패키지는 jar 파일로 압축할수 있다
## 자바 모듈
여러 패키지와 이미지 등의 자원을 모아 놓은 컨테이너  
하나의 모듈을 하나의 .jmod파일에 저장
## 자바의 모듈화의 목적
Java9 부터 자바 API를 여러 모듈로 분할  
-Java8 까진 rt.jar의 한 파일에 모든 API저장  
응용프로그램이 실행할떄 꼭 필요한 모듈들로만 실행환경 구축  
-메모리 자원이 열악한 작승 소형기기에 꼭필요한 모듈로 구성된 작은 크기의 실행 이미지를 만들기 위함
## 자바의 모듈화의 현실
Java 9 부터 전면적으로 도입  
복잡한 개념  
큰자바 응용프로그램에는 개발, 유지보수 등에 적합  
현실적으로 모듈로 나누어 자바 프로그램을 작성할 필요없음
## 자바 API의 모듈 파일들
자바가 설치된 jmods 디렉터리에 모듈파일 존재  
-jmod 확장자를 가진 파일  
-모듈은 수십개  
## 패키지 사용하기
import를 이용하지 않은 경우 
-소스에 클래스 이름의 완전 경로명 사용  
필요한 클래스만 import  
-소스 시작 부분에 클래스의 경로명 import  
-import 패키지.클래스
-소스에는 클래스 명만 명시하면됨
## 패키지 만들기
클래스 파일이 저장되는 위치는?  
-클래스나 인터페이스가 컴파일 되면 클래스 파일 생성  
-클래스 파일은 패키지로 선언된 디렉토리 파일에 저장  
패키지 선언  
-소스파일의 맨 앞에 컴파일 후 저장된 퍀지 지정  
-package 패키지명;
## 모듈 개념
Java9에서 도입된 개념  
패키지지와 이미지 등의 리소스를 담은 컨테이너
## 자바 플랫폼
자바의 개발 환경(JDK)과 자바의 실행 환경(JRE)을 지칭  
자바 API의 묻는 클래스가 여러개의 모듈로 재구성됨  
모듈 파일은 JDK
## 자바 모듈화의 목적
자바 컴포넌트들을 필요에 따라 조립하여 사용하기 위함  
컴퓨터 시스템의 불필요한 부담 감소  
## Object 클래스
모든 자바 클래스는 반드시 Object를 상속 받다록 자동 컴파일  
-모든 클래스의 수퍼 클래스  
-모든 클래스가 상속 받는 공통 매소드 포함
## toString() 메소드 객체를 문자열로 변환
각 클래스는 toString()을 오버라이딩 하여 자신만의 문자열 리턴 가능  
-객체를 문자열로 변환  
-원형(public static toString();)  
컴파일러에 의한 toString() + 문자열로 자동 변환
## 객체 비교(==)와 equals() 메소드
==연산자  
-객체 레퍼런스 비교  
boolean equals(Object obj)  
-두 객체의 내용물 비교  
-객체의 내용물을 비교하기 위해 클래스의 멤버로 작성
## Wrapper 클래스
자바의 기본 타입을 클래스화한 8개 클래스를 통칭  
용도  
-객체만 사용할수 있는 컬렉션 등에 기본 타입의 값을 사용하기 위해  
->Wrapper 객체로 만들어 사용
## 박싱 언박싱
박싱  
-기본 타입의 값을 Wrapper 객체로 변환하는것  
언박싱  
-Wrapper 객체에 들어있는 기본 타입의 값을 빼내는것  
-박싱과 반대  
자동 박싱과 자동 언박싱  
-JDK1.5 부터 박싱과 언박싱은 자동으로 어우러지도록 컴파일됨
## Math 클래스
기본 산술 연산 메소드를 제공하는 클래스  
모든 메소드는 static으로 선언  
Math.random() 메소드로 난수 발생
## 
## 4월 12일 강의
## static 멤버의 생성
static 멤버는 클래스당 하나만 생성  
객체들에 의해 공유됨
## static 멤버의 사용
클래스 이름으로 접근가능  
객체의 멤버로 접근 가능  
static 멤버는 클래스 이름으로 접근 안됨
## static 멤버의 예시
```
class Calc{
    int foo;
    static int bar;

    public static int abs(int a){return a>0?a:-a;}
    public static int max(int a, int b){return (a>b)?a:b;}
    public static int min(int a, int b){return (a>b)?b:a;}
}
public class Ex4_11{
public static void main(String[] args){
    System.out.println(Calc.abs(-5));
    System.out.println(Calc.max(a:10, b:8));
    System.out.println(Calc.min(-3, -8));
    Cal a = new Calc();
    a.foo = 100;
    Cal.bar=50;
    System.out.println(a.foo);
    System.out.println(Calc.bar);
    }
}
```
## static 메소드의 제약 조건
static 메소드는 오직 static 멤버만 접근 가능  
-객체가 생성되지 않은 상황에서도 staic 메소드는 실행될수 있기 떄문에 non-static 멤버 활용 불가  
-non-static 메소드는 static 멤버 사용가능
## static 메소드의 제약조건 2
static 메소드는 this 사용불가  
-static 메소드는 객체 없이도 사용 가능하므로 this레퍼런스 사용 불가
## final 클래스와 메소드
final class: 더이상 클래스 상속 불가능  
final 메소드: 더이상 오버라이딩 불가능
## final 필드
final 필드, 상수 선언  
-상수를 선언할때 사용  
상수 필드는 선언시에 초기 값을 지정해야 한다  
상수 필드는 실행중에 값을 변경 할수 없다 
### 5장
## 상속
객체지향 상속  
상속의 필요성  
-상속이 없는경우 중복된 멤버를 가진 클래스  
-상속을 이용한 경우 중복이 제거되고 간결해진 클래스 구조  
-공통적인것을 뽑아내 사용하는것
## 클래스 상속과 객체
상속 선언  
-extend 키워드로 선언  
(부모 클래스를 물려 받아 확장한다는 의미)
-부모 클래스 -> 슈퍼 클래스  
-자식 클래스 -> 서브 클래스
(colorPoint 는 Point를 물려 받으므로, Point에 선언된 필드와 메소드에 선언된 필드는 상관 없음)
## 예제 5-1
```
package chapter05;

public class Ex05_1{
    public static void mian(String[] args) {
        Point p = new Point();
        p.set(x:1, y:2);
        p.showPoint();
        
        ColorPoint cp=new ColorPoint();
        cp.set(x:3, y:4);
        cp.setColor(color:"red");
        cp.showColorPoint();
        }
    }       
    class Point{
        private int x,y;
        public void set(int x, int y){
            this.x = x;
            this.y = y;
        }
        public void showPoint
        System.out.println("("+x+","+y+")");
    }

class ColorPoint extends Point{
    private String color;
    public void setColor(String color){
        this.color=color;
    }
    public void showColorPoint(){
        System.out.println(color);
        showPoint();
    }
}
```
## 서브 클래스 객체의 모양
슈퍼 클래스 객체와 서브 클래스의 객체는 별개  
서브 클래스 객체는 슈퍼 클래스 멤버 포함
## 슈퍼 클래스의 멤버에 대한 서브 클래스의 접근 
슈퍼 클래스의 private 멤버  
-서브 클래스에서 접근할 수 없음  
슈퍼 클래스의 디폴트 멤버  
-서브 클래스가 동일한 패키지에 있을때 접근 가능  
슈퍼 클래스의 public멤버  
-서브 클래스는 항상 접근가능  
슈퍼 클래스의 protected 멤버  
-같은 패키지 내의 모든 클래스 접근 허용 패키지 여부와 상관 없이 서브클래스는 접근 가능
## protected 멤버
같은 패키지의 모든 클래스에게 허용  
상속되는 서브 클래스(같은 패키지든 다른 패키지든 상관 없음)에게 허용
## 서브/슈퍼 클래스의 생성자 호출과 실행
서브 클래스의 객체가 생성 될때  
-슈퍼 클래스 생성자와 서브 클래스 생성자 모두 실행  
## 서브/슈퍼 클래스의 생성자 선택
슈퍼 클래스와 서브 클래스  
-각각 여러개의 생성자 작성가능  
서브 클래스의 객체가 생성 될때  
-슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행  
서브/슈퍼 클래스의 생성자가 결정되는 방식  
1. 개발자의 명시적 선택  
-서브 클래스 개발자가 슈퍼 클래스의 생성자 명시적 선택  
2. 컴파일러가 기본 생성자 선택  
-서브 클래스 개발자가 슈퍼 클래스의 생성자를 선택하지 않은경우  
## super()로 슈퍼 클래스의 생성자 명시적 선택
서브 클래스에서 명시적으로 슈퍼 클래스의 생성자 선택 호출
## 업캐스팅
서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입   
슈퍼 클래스 레퍼런스로 서브 클래스 객체를 가리키게 되는 현상
## 다운캐스팅
슈퍼 클래스 레퍼런스를 서브 클래스 레퍼런스에 대입  
업캐스팅된 것을 다시 원래대로 되돌리는것  
반드시 명시적 타입 변환 지정
## 업캐스팅 레퍼런스로 객체 구별
업캐스팅된 레퍼런스로는 객체의 실제 타입을 구분하기 어려움
## instanceof 연산자
레퍼런스가 가리키는 객체의 타입 식별
## 메소드 오버라이딩
서브 클래스에서 슈퍼 클래스의 메소드 중복 작성  
슈퍼 클래스의메소드 무력화 항상 서브 클래스에 오버라이딩한 메소드가 실행되도록 보장  
## 오버라이딩 조건
슈퍼 클래스 메소드의 원형(메소드이름 인자 타입 및 개수, 리턴타입) 동일하게 작성
## 오버라이딩 목적
하나의 인터페이스에 서로 다른 구현  
슈퍼 클래스의 메소드를 서브 클래스에서 각각 목적에 맞게 다르게 구현
## super 키워드로 슈퍼 클래스의 멤버 접근
슈퍼 클래스의 멤버를 접근할떄 사용되는 레퍼런스(super.멤버)  
서브 클래스에서만 사용  
슈퍼 클래스의 필드 접근  
슈퍼 클래스의 메소드 호출시  
super로 잉루어 지는 메소드호출: 정적 바인딩
## 오버로딩
관계: 같은 클래스나 상속 관계에서 동일한 이름의 메소드 중복 작성  
: 동일한 클래스내 혹은 상속 관계  
: 이름이 같은 여러개의 메소드를 중복 선언하여 편리성 향상  
조건: 메소드 이름은 반드시 동일, 메소드의 인자 개수나 인자의 타입이 달라야 성립  
바인딩: 정적 바인딩 컴파일 시에 중복된 메소드 중 호출되는 메소드 결정
## 추상 메소드
abstract로 선언된 메소드, 메소드의 코드는 없고 원형만 선언
## 추상 클래스
추상 메소드를 가지며 abstract로 선언된 클래스  
추상 메소드 없이 abstract로 선언한 클래스

## 4월 5일 강의
## 메소드의 배열 리턴
배열 리턴  
-배열의 레퍼런스만 리턴(배열 전체가 리턴되는것이 아님)  
메소드의 리턴타입  
-리턴하는 배열 타입과 리턴받는배열 타입일치  
-리턴 타입에 배열의 크기를 지정하지 않음
## 자바의 예외 처리
예외  
-실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황발생
(자바에서는 실행중 발생하는 에러를 예외로 처리)  
실행 중 예외가 발생하면  
-자바 플랫폼은 응용프로그램이 예외를 처리하도록 호출(응용 프로그램이 예외를 처리하지 않으면 프로그램을 강제 종료시킴)  
예외 발생 경우  
-정수를 0으로 나누는 경우
## 예외 처리
발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것  
try-catch-finally문 사용(finally 블록은 생략 가능)
## 예외 클래스 사례
배열의 범위를 벗어나 원소를 접근하는 예외 처리
## 세상 모든것이 객체다
세상 모든것이 객체다  
실세계 객체의 특징  
-객체마다 고유한 특성과 행동을 가짐  
-다른 객체들과 정보를 주고 받는중 상호작용하며 살아감  
컴퓨터 프로그램에서 객체 사례
-테트리스 게임의 블록들  
-한글 프로그램의 메뉴나 버튼들
## 캡슐화
캡슐화: 객체를 캡슐로 싸서 내부를 볼수 없게 하는것  
-객체의 가장 본질적인 특징(외부의 접근으로부터 보호)  
자바의 캡슐화  
-클래스: 객체 모양을 선언한 틀  
-객체: 생성된 실체(클래스 내에 메소드와 필드 구현)
## 상속
상위 개체의 속성이 하위개체에 물려짐  
하위 개체가 상위 개체의 속성을 모두 가지는 관계
## 자바 상속
상위 클래스의 맴버를 하위 클래스가 물려받음  
-상위 클래스: 슈퍼 클래스  
-하위 클래스: 서브 클래스, 슈퍼 클래스의 재사용, 새로운 특성 추가 기능
## 자바의 객체 지향 특성: 다형성
같은 이름의 매소드가 클래스 혹은 객체에 따라 다르게 구현되는것  
다형성 사례  
-메소드 오버로딩:한클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드  
-메소드 오버라이딩: 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현
## 객체 지향 언어의 목적
소프트 웨어의 생산성 향상  
-컴퓨터 산업 발전에 따라 소프트웨어의 생명주기 단축  
-객체 지향 언어
실세계에 대한 쉬운 모델링  
-초기 프로그래밍  
-현대 프로그래밍  
-객체 지향 언어
## 절차지향 프로그래밍
작엄 순서를 표현하는 컴퓨터 명령 집합  
함수들의 집합으로 프로그램 작성
## 객체지향 프로그래밍
컴퓨터가 수행 하는 작업을 객체들 간의 상호 작용으로 표현  
클래스 혹은 객체들의 집합으로 프로그램 작성
## 클래스
객체의 속성과 행위 선언  
객체의 설계도 혹은 틀
## 객체
클래스의 틀로 찍어낸 실체  
-프로그램 실행중에 생성되는 실체  
-메모리 공간을 갖는 구체적인 실체  
-인스턴스(instance)라고 부름
## 클래스의 구성
class 키워드로 선언  
멤버: 클래스 구성 요소  
클래스에 대한 public 접근 지정:다른 모든 클래스에서 클래스 사용 허락  
멤버에 대한 public 접근 지정: 다른 모든 클래스 사용 허락
## 생성자
객체가 생성될떄 초기화를 목적으로 실행되는 매소드  
객체가 생성되는 순간에 자동 호출
## 생성자 특징
생성자 이름은 클래스 이름 동일  
생성자는 여러개 작성 가능  
생성자는 객체 생성시 한번만 호출  
생성자의 목적은 객체 생성시 초기화  
생성자는 리턴 타입을 지정할수 없음
## 기본 생성자
매게 변수 없고, 아무작업 없이 단순 리턴하는 생성자  
디폴트 생성자라고도 불림
## this 레퍼런스(레퍼런스=주소)
객체 자신에 대한 레퍼런스  
-컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면됨  
-this.멤버 형태로 멤버를 접근할때 사용
## this() 다른 생성자호출
같은 클래스에서 와 다른 생성자 호출  
생성자 내에서만 사용가능  
생성자 코드의 해당 이름에 있어야함
## 객체배열
자바의 객체 배열  
-객체에 대한 레퍼런스 배열임  
자바의 객체 배열 만들기 3단계  
1 배열 레퍼런스 변수 선언  
2 래퍼런스 배열 생성  
3 배열의 각 원소 객체 생성
## 메소드
메소드는 C/C++의 함수화 동일  
자바의 모든 메소드는 반드시 클래스 안에 있어야함  
접근 지정자  
리턴 타입
## 매소드 오버로딩
한 클래스 내에서 두개 이상의 이름이 같은 메소드 작성  
-메소드 이름이 동일해야함  
-매개변수의 개수가 서로 다르거나 -타입이 서로 달라야함  
-리턴 타입은 오버로딩과 상관없음
## 객체소멸
new에 의해 할당받은 객체와 배열 메모리를 자바 가상기계로 되돌려 주는 행위  
소멸된 객체 공간은 가용 메모리에 포함
## 자바에서 사용자 임의로 객체 소멸 안됨
자바는 객체 소멸 연산자 없음  
-객체 생성 연산자:new 
객체 소멸은 자바 가상 기계의 고유한 역활  
자바 개발자에게는 매우 다행스러운 기능  
-C/C++에서는 할당 받은 객체를 개발자가 프로그램 내에서 삭제 해야함  
-C/C++의 프로그램 작성을 어렵게 만든느 요인  
-자바에서는 사용하지 않는 객체나 배열을 돌려주는 코딩 책임으로 부터 개발자 해방
## 가비지
가리키는 레퍼런스가 하나도 없는 객체  
-더이상 접근할수 없어 사용할수 없게된 메모리
## 가비지 컬렉션
자바 가상기계가 가비지 자동 회수  
-가용 메모리 공간이 일정 이하로 부족해질때  
-가비지를 수거하여 가용 메로리 공간으로 확보  
가비지 컬렉터(garbage collator)에 의해 자동 수행  
## 강제 가비지 컬렉션 강제 수행
System 또는 Runtime 객체의 gc() 메소드 호출
## 자바의 패키지 개념
패키지  
-상호 관련있는 클래스 파일을 저장하여 관리하는 디렉터리  
-자바 응용프로그램은 하나 이상의 패키지로 구성
## 접근 지정자
자바의 접근 지정자 4가지  
-private, protected, public, default(접근 지정자 생략)  
접근 지정자의 목적  
-클래스나 일부멤버를 공개항 다른 클래스에서 접근하도록 허용  
-객체 지향 언어의 캡슐화 정책은 맴버를 보호하는것
## 클래스 접근 지정
다른 클래스에서 사요하도록 허용할지 지정  
public 클래스(다른 모든 크랠스에게 접근 허용)  
-다른 모든 클래스에게 접근허용
디폴트 클래스(접근 지정자 생략)
## 3월29일 강의
## 타입변환  
한 타입의 값을 다른 타입의 값으로 변환  
## 자동 타입 변환  
컴파일러에 의해 원래의 타입보다 큰 타입으로 자동변환  
치환문이나 수식 내에서 타입이 일치하지 않을때  
## 강제 타입 변환
개발자의 의도적 타입 변환  
()안에 개발자가 명시적으로 타입변환 지정  
강제 변환은 값 손실 우려

## 자바의 키 입력과 System.in
키보드와 연결된 자바의 표준 입력 스트림  
입력되는 키를 바이트로 리턴하는 저수준 스트림  
System.in을 직접 사용하면 바이트를 문자나 숫자로 변환한느 많은 어려움이 있음

## Scanner 클래스
읽은 바이트를 문자,정수,실수,불린,문자열 등 다양한 타입으로 변환하여 리턴  
-java.util.Scanner  
객채 생성  
-키보드에 연결된 System.in 에게 키를 읽게한다

## Scanner를 이용한 키 입력
개발자가 원하는 타입 값으로 쉽게 읽을수 있음

## 식과 연산자
연산  
-주어진 식을 계산하여 결과를 얻어내는 과정

## 산술 연산자
-더하기, 빼기, 곱하기, 나누기, 나머지  
-/와 % 응용

## 증감연산
a++: a를 1증가하고 증가 전의 값 반환  
a--: a를 1감소하고 감소 전의 값 반환  
++a: a를 1증가하고 증가된 값 반환  
--a: a를 1감소하고 감소된 값 반환  

## 조건 연산
3개의 피연산자로 구성된 삼항 연산자  
-opr1?opr2:opr3  
-opr1이 true면, 연산식 결과는 opr2, false면 opr3  
if-else를 조건 연산자로 간결하게 표현 가능

## 비트 논리 연산
피 연산자의 각 비트들을 대상으로 하는 연산

## 조건문 - 단순 if문, if-else문
단순 if문
if의 관호 안에 조건식(논리형 변수나 논리 연산)  
-실행문장이 단일 문장인 경우 둘러 싸는{,} 생략가능  
if-else문  
-조건식이 true면 실행문장1,   false면 실행문장2

## switch문
switch문은 식과 case문의 값과 비교  
-case의 비교 값과 일치하면 해당 case의 실행문장 수행  
    -break를 만나면 switch문 벗어남  
-case의 비교 값과 일치하는 것이 없으면 default문 실행

## case문의 값
문자, 정수, 문자열 리터럴만 허용  
실수 리터럴은 허용되지 않음

### 3장
## 반복문
for 문  
-가장 많이 사용되는 반복문  
while 문  
    -조건식이 참인 동안 반복 실행  
do-while문  
    -조건식이 참인 동안 반복 실행  
    -작업문은 한번 반드시 실행

## break 문
반복문 하나를 즉시 벗어갈떄 사용  
-하나의 반복문만 벗어남  

## 자바 배열(Array)
인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료구조  
-배열을 이용하면 한번에 많은 메모리 공간 선언가능  
배열은 같은 타입의 데이터들이 순차적으로 저장되는 공간  
-원소 데이터들이 순차적으로 저장됨  
-인덱스를 이용하여 원소 데이터 접근  
-반복문을 이용하여 처리하기에 적합한 자료구조  
배열 인덱스  
-0부터 시작  
-인덱스는 배열의 시작 위치에서부터 데이터가 있는 상대위치

## 배열 선언 및 생성 디테일
배열 선언과 배열 생성의 두단계 필요  
배열 선언  
-배열의 이름 선언  
배열 생성  
-배열 공간 할당 받는 과정  
배열 초기화  
-배열 생성과 값 초기화

## 배열의 크기, lengh로 정리
자바 배열은 객체로 처리  
-배열 객체의 lengh 필드  

## 함수 호출시 배열 전달 비교
-c/c++의 경우 배열과 크기를 각각 전달받음  
-자바 경우 배열만 전달 받음 

## 배열과 for-each 문
배열이나 나열의 원소를 순차 접근하는데 유용한 for문  

## 3월22일 강의
ctrl+shift+p로 새로운 자바 파일을 만들수 있다  

저급언어: 컴퓨터가 이해하기 쉬운 언어 (기계어, 어셈블리어)  
고급언어: 사람이 이해하기 쉬운 언어(C/C++, Java, C#)  

소스: 프로그래밍 언어로 작성된 텍스트 파일  
컴파일: 소스파일을 컴퓨터가 이해할수 있는 기계어로 만드는 과정  

## WORA(Write Once Run Anywhere)  
-한번 작성된 코드는 모든 플랫폼에서 실행되는 자바파일  
-C/C++ 등 기존 언어가 가진 플랫폼 종속성 극복  
-네트워크에 연결된 어느 클라이언트에서나 실행  
WORA를 가능하게 하는 자바의 특징  
-바이트 코드(byte code)  
1 자바 소스를 컴파일한 목적 코드  
2 CPU에 종속적이지 않은 중립적인 코드  

## 자바 API(Applicsation Programming Interfacr)란  
-JDK에 포함된 클래스 라이브러리  

## IDE(Intergrated Development Environment)란  
-통합개발 환경  
-편집, 컴파일, 디버깅을 한번에 할수있는 통합된  개발 환경  

## 이클립스(Eclipse)  
-자바 응용 프로그램 개발을 위한 통합 개발 프로그램  
-IBM에 의해 개발된 오픈소스 프로젝트  

## 서블릿(servlet)  
웹서버에서 실행되는 자바 프로그램  

## 자바 특징  
-플랫폼 독립성  
-객체지향  
-클래스로 캡슐화  
-소스(.java)와 클래스(.class)파일  
-실행코드 배포  
-패키지  
1 서로 관련있는 여러 클래스를 패키지로 묶어 관리  
-멀티스레드  
1 여러 스레드의 동시 수행 환경 지원  
-가비지 컬렉션

## 자바의 단점  
-실시간 응용프로그램에 부적함  
-자바 프로그램은 안전  
-프로그램 작성 쉬움  
-실행속도 개선을 위한 JIT컴파일러 사용  
식별자란?  
-클래스 변수 상수 메소드 등에 붙이는 이름  
-식별자의 원칙  
1 대소문자 구별  
2 int barChart; 와 int barchart;는 서로 다르게 구별

## 자바의 데이터 타입  
-기본타입: 8개  
boolean, char, byte, short, int, long, float, double  

## 문자열  
문자열은 기본 타입이 아님  

## 변수와 선언  
-변수  
프로그램 실행 중에 값을 임시 저장하기 위한 공간  
-변수선언  
데이터 타입에서 정한 크기의 메모리 할당  

## 리터럴(literal)  
-프로그램에서 직접 표현한 값  
-정수,실수,문자,논리,문자열 리터럴이 있음  
정수 리터럴  
실수 리터럴  
-실수 타입리터럴은 double타입으로 컴파일
문자 리터럴  
-단일 인용부호('')로 문자표현  
-특수문자 리터럴은 백슬래시(\)로 시작  
## 상수
상수 선언  
-final 키워드 사용  
-선언시 초깃값 지정  
-실행중 값 변경불가  

##  var 키워드
-Java 10부터 도입  
-기존의 변수 선언 방식: 변수의 타입 반드시 지정  
-var키워드  
1 타입을 생략하고 변수 선언 가능  
2 컴파일러가 추론하여 변수 타입 결정  
3 변수 선언시 초깃값이 주어지지 않으면 컴파일 오류  
4 var은 지역 변수 선언에만 한정   

## 3월 15일 강의
내용정리