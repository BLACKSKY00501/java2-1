# 임동욱 학번202330127
## 4월 12일 강의
## static 멤버의 생성
static 멤버는 클래스당 하나만 생성  
객체들에 의해 공유됨
## static 멤버의 사용
클래스 이름으로 접근가능  
객체의 멤버로 접근 가능  
static 멤버는 클래스 이름으로 접근 안됨
## static 멤버의 예시
```
class Calc{
    int foo;
    static int bar;

    public static int abs(int a){return a>0?a:-a;}
    public static int max(int a, int b){return (a>b)?a:b;}
    public static int min(int a, int b){return (a>b)?b:a;}
}
public class Ex4_11{
public static void main(String[] args){
    System.out.println(Calc.abs(-5));
    System.out.println(Calc.max(a:10, b:8));
    System.out.println(Calc.min(-3, -8));
    Cal a = new Calc();
    a.foo = 100;
    Cal.bar=50;
    System.out.println(a.foo);
    System.out.println(Calc.bar);
    }
}
```
## static 메소드의 제약 조건
static 메소드는 오직 static 멤버만 접근 가능  
-객체가 생성되지 않은 상황에서도 staic 메소드는 실행될수 있기 떄문에 non-static 멤버 활용 불가  
-non-static 메소드는 static 멤버 사용가능
## static 메소드의 제약조건 2
static 메소드는 this 사용불가  
-static 메소드는 객체 없이도 사용 가능하므로 this레퍼런스 사용 불가
## final 클래스와 메소드
final class: 더이상 클래스 상속 불가능  
final 메소드: 더이상 오버라이딩 불가능
## final 필드
final 필드, 상수 선언  
-상수를 선언할때 사용  
상수 필드는 선언시에 초기 값을 지정해야 한다  
상수 필드는 실행중에 값을 변경 할수 없다 
### 5장
## 상속
객체지향 상속  
상속의 필요성  
-상속이 없는경우 중복된 멤버를 가진 클래스  
-상속을 이용한 경우 중복이 제거되고 간결해진 클래스 구조  
-공통적인것을 뽑아내 사용하는것
## 클래스 상속과 객체
상속 선언  
-extend 키워드로 선언  
(부모 클래스를 물려 받아 확장한다는 의미)
-부모 클래스 -> 슈퍼 클래스  
-자식 클래스 -> 서브 클래스
(colorPoint 는 Point를 물려 받으므로, Point에 선언된 필드와 메소드에 선언된 필드는 상관 없음)
## 예제 5-1
```
package chapter05;

public class Ex05_1{
    public static void mian(String[] args) {
        Point p = new Point();
        p.set(x:1, y:2);
        p.showPoint();
        
        ColorPoint cp=new ColorPoint();
        cp.set(x:3, y:4);
        cp.setColor(color:"red");
        cp.showColorPoint();
        }
    }       
    class Point{
        private int x,y;
        public void set(int x, int y){
            this.x = x;
            this.y = y;
        }
        public void showPoint
        System.out.println("("+x+","+y+")");
    }

class ColorPoint extends Point{
    private String color;
    public void setColor(String color){
        this.color=color;
    }
    public void showColorPoint(){
        System.out.println(color);
        showPoint();
    }
}
```
## 서브 클래스 객체의 모양
슈퍼 클래스 객체와 서브 클래스의 객체는 별개  
서브 클래스 객체는 슈퍼 클래스 멤버 포함
## 슈퍼 클래스의 멤버에 대한 서브 클래스의 접근 
슈퍼 클래스의 private 멤버  
-서브 클래스에서 접근할 수 없음  
슈퍼 클래스의 디폴트 멤버  
-서브 클래스가 동일한 패키지에 있을때 접근 가능  
슈퍼 클래스의 public멤버  
-서브 클래스는 항상 접근가능  
슈퍼 클래스의 protected 멤버  
-같은 패키지 내의 모든 클래스 접근 허용 패키지 여부와 상관 없이 서브클래스는 접근 가능
## protected 멤버
같은 패키지의 모든 클래스에게 허용  
상속되는 서브 클래스(같은 패키지든 다른 패키지든 상관 없음)에게 허용
## 서브/슈퍼 클래스의 생성자 호출과 실행
서브 클래스의 객체가 생성 될때  
-슈퍼 클래스 생성자와 서브 클래스 생성자 모두 실행  
## 서브/슈퍼 클래스의 생성자 선택
슈퍼 클래스와 서브 클래스  
-각각 여러개의 생성자 작성가능  
서브 클래스의 객체가 생성 될때  
-슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행  
서브/슈퍼 클래스의 생성자가 결정되는 방식  
1. 개발자의 명시적 선택  
-서브 클래스 개발자가 슈퍼 클래스의 생성자 명시적 선택  
2. 컴파일러가 기본 생성자 선택  
-서브 클래스 개발자가 슈퍼 클래스의 생성자를 선택하지 않은경우  
## super()로 슈퍼 클래스의 생성자 명시적 선택
서브 클래스에서 명시적으로 슈퍼 클래스의 생성자 선택 호출
## 업캐스팅
서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입   
슈퍼 클래스 레퍼런스로 서브 클래스 객체를 가리키게 되는 현상
## 다운캐스팅
슈퍼 클래스 레퍼런스를 서브 클래스 레퍼런스에 대입  
업캐스팅된 것을 다시 원래대로 되돌리는것  
반드시 명시적 타입 변환 지정
## 업캐스팅 레퍼런스로 객체 구별
업캐스팅된 레퍼런스로는 객체의 실제 타입을 구분하기 어려움
## instanceof 연산자
레퍼런스가 가리키는 객체의 타입 식별
## 메소드 오버라이딩
서브 클래스에서 슈퍼 클래스의 메소드 중복 작성  
슈퍼 클래스의메소드 무력화 항상 서브 클래스에 오버라이딩한 메소드가 실행되도록 보장  
## 오버라이딩 조건
슈퍼 클래스 메소드의 원형(메소드이름 인자 타입 및 개수, 리턴타입) 동일하게 작성
## 오버라이딩 목적
하나의 인터페이스에 서로 다른 구현  
슈퍼 클래스의 메소드를 서브 클래스에서 각각 목적에 맞게 다르게 구현
## super 키워드로 슈퍼 클래스의 멤버 접근
슈퍼 클래스의 멤버를 접근할떄 사용되는 레퍼런스(super.멤버)  
서브 클래스에서만 사용  
슈퍼 클래스의 필드 접근  
슈퍼 클래스의 메소드 호출시  
super로 잉루어 지는 메소드호출: 정적 바인딩
## 오버로딩
관계: 같은 클래스나 상속 관계에서 동일한 이름의 메소드 중복 작성  
: 동일한 클래스내 혹은 상속 관계  
: 이름이 같은 여러개의 메소드를 중복 선언하여 편리성 향상  
조건: 메소드 이름은 반드시 동일, 메소드의 인자 개수나 인자의 타입이 달라야 성립  
바인딩: 정적 바인딩 컴파일 시에 중복된 메소드 중 호출되는 메소드 결정
## 추상 메소드
abstract로 선언된 메소드, 메소드의 코드는 없고 원형만 선언
## 추상 클래스
추상 메소드를 가지며 abstract로 선언된 클래스  
추상 메소드 없이 abstract로 선언한 클래스

## 4월 5일 강의
## 메소드의 배열 리턴
배열 리턴  
-배열의 레퍼런스만 리턴(배열 전체가 리턴되는것이 아님)  
메소드의 리턴타입  
-리턴하는 배열 타입과 리턴받는배열 타입일치  
-리턴 타입에 배열의 크기를 지정하지 않음
## 자바의 예외 처리
예외  
-실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황발생
(자바에서는 실행중 발생하는 에러를 예외로 처리)  
실행 중 예외가 발생하면  
-자바 플랫폼은 응용프로그램이 예외를 처리하도록 호출(응용 프로그램이 예외를 처리하지 않으면 프로그램을 강제 종료시킴)  
예외 발생 경우  
-정수를 0으로 나누는 경우
## 예외 처리
발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것  
try-catch-finally문 사용(finally 블록은 생략 가능)
## 예외 클래스 사례
배열의 범위를 벗어나 원소를 접근하는 예외 처리
## 세상 모든것이 객체다
세상 모든것이 객체다  
실세계 객체의 특징  
-객체마다 고유한 특성과 행동을 가짐  
-다른 객체들과 정보를 주고 받는중 상호작용하며 살아감  
컴퓨터 프로그램에서 객체 사례
-테트리스 게임의 블록들  
-한글 프로그램의 메뉴나 버튼들
## 캡슐화
캡슐화: 객체를 캡슐로 싸서 내부를 볼수 없게 하는것  
-객체의 가장 본질적인 특징(외부의 접근으로부터 보호)  
자바의 캡슐화  
-클래스: 객체 모양을 선언한 틀  
-객체: 생성된 실체(클래스 내에 메소드와 필드 구현)
## 상속
상위 개체의 속성이 하위개체에 물려짐  
하위 개체가 상위 개체의 속성을 모두 가지는 관계
## 자바 상속
상위 클래스의 맴버를 하위 클래스가 물려받음  
-상위 클래스: 슈퍼 클래스  
-하위 클래스: 서브 클래스, 슈퍼 클래스의 재사용, 새로운 특성 추가 기능
## 자바의 객체 지향 특성: 다형성
같은 이름의 매소드가 클래스 혹은 객체에 따라 다르게 구현되는것  
다형성 사례  
-메소드 오버로딩:한클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드  
-메소드 오버라이딩: 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현
## 객체 지향 언어의 목적
소프트 웨어의 생산성 향상  
-컴퓨터 산업 발전에 따라 소프트웨어의 생명주기 단축  
-객체 지향 언어
실세계에 대한 쉬운 모델링  
-초기 프로그래밍  
-현대 프로그래밍  
-객체 지향 언어
## 절차지향 프로그래밍
작엄 순서를 표현하는 컴퓨터 명령 집합  
함수들의 집합으로 프로그램 작성
## 객체지향 프로그래밍
컴퓨터가 수행 하는 작업을 객체들 간의 상호 작용으로 표현  
클래스 혹은 객체들의 집합으로 프로그램 작성
## 클래스
객체의 속성과 행위 선언  
객체의 설계도 혹은 틀
## 객체
클래스의 틀로 찍어낸 실체  
-프로그램 실행중에 생성되는 실체  
-메모리 공간을 갖는 구체적인 실체  
-인스턴스(instance)라고 부름
## 클래스의 구성
class 키워드로 선언  
멤버: 클래스 구성 요소  
클래스에 대한 public 접근 지정:다른 모든 클래스에서 클래스 사용 허락  
멤버에 대한 public 접근 지정: 다른 모든 클래스 사용 허락
## 생성자
객체가 생성될떄 초기화를 목적으로 실행되는 매소드  
객체가 생성되는 순간에 자동 호출
## 생성자 특징
생성자 이름은 클래스 이름 동일  
생성자는 여러개 작성 가능  
생성자는 객체 생성시 한번만 호출  
생성자의 목적은 객체 생성시 초기화  
생성자는 리턴 타입을 지정할수 없음
## 기본 생성자
매게 변수 없고, 아무작업 없이 단순 리턴하는 생성자  
디폴트 생성자라고도 불림
## this 레퍼런스(레퍼런스=주소)
객체 자신에 대한 레퍼런스  
-컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면됨  
-this.멤버 형태로 멤버를 접근할때 사용
## this() 다른 생성자호출
같은 클래스에서 와 다른 생성자 호출  
생성자 내에서만 사용가능  
생성자 코드의 해당 이름에 있어야함
## 객체배열
자바의 객체 배열  
-객체에 대한 레퍼런스 배열임  
자바의 객체 배열 만들기 3단계  
1 배열 레퍼런스 변수 선언  
2 래퍼런스 배열 생성  
3 배열의 각 원소 객체 생성
## 메소드
메소드는 C/C++의 함수화 동일  
자바의 모든 메소드는 반드시 클래스 안에 있어야함  
접근 지정자  
리턴 타입
## 매소드 오버로딩
한 클래스 내에서 두개 이상의 이름이 같은 메소드 작성  
-메소드 이름이 동일해야함  
-매개변수의 개수가 서로 다르거나 -타입이 서로 달라야함  
-리턴 타입은 오버로딩과 상관없음
## 객체소멸
new에 의해 할당받은 객체와 배열 메모리를 자바 가상기계로 되돌려 주는 행위  
소멸된 객체 공간은 가용 메모리에 포함
## 자바에서 사용자 임의로 객체 소멸 안됨
자바는 객체 소멸 연산자 없음  
-객체 생성 연산자:new 
객체 소멸은 자바 가상 기계의 고유한 역활  
자바 개발자에게는 매우 다행스러운 기능  
-C/C++에서는 할당 받은 객체를 개발자가 프로그램 내에서 삭제 해야함  
-C/C++의 프로그램 작성을 어렵게 만든느 요인  
-자바에서는 사용하지 않는 객체나 배열을 돌려주는 코딩 책임으로 부터 개발자 해방
## 가비지
가리키는 레퍼런스가 하나도 없는 객체  
-더이상 접근할수 없어 사용할수 없게된 메모리
## 가비지 컬렉션
자바 가상기계가 가비지 자동 회수  
-가용 메모리 공간이 일정 이하로 부족해질때  
-가비지를 수거하여 가용 메로리 공간으로 확보  
가비지 컬렉터(garbage collator)에 의해 자동 수행  
## 강제 가비지 컬렉션 강제 수행
System 또는 Runtime 객체의 gc() 메소드 호출
## 자바의 패키지 개념
패키지  
-상호 관련있는 클래스 파일을 저장하여 관리하는 디렉터리  
-자바 응용프로그램은 하나 이상의 패키지로 구성
## 접근 지정자
자바의 접근 지정자 4가지  
-private, protected, public, default(접근 지정자 생략)  
접근 지정자의 목적  
-클래스나 일부멤버를 공개항 다른 클래스에서 접근하도록 허용  
-객체 지향 언어의 캡슐화 정책은 맴버를 보호하는것
## 클래스 접근 지정
다른 클래스에서 사요하도록 허용할지 지정  
public 클래스(다른 모든 크랠스에게 접근 허용)  
-다른 모든 클래스에게 접근허용
디폴트 클래스(접근 지정자 생략)
## 3월29일 강의
## 타입변환  
한 타입의 값을 다른 타입의 값으로 변환  
## 자동 타입 변환  
컴파일러에 의해 원래의 타입보다 큰 타입으로 자동변환  
치환문이나 수식 내에서 타입이 일치하지 않을때  
## 강제 타입 변환
개발자의 의도적 타입 변환  
()안에 개발자가 명시적으로 타입변환 지정  
강제 변환은 값 손실 우려

## 자바의 키 입력과 System.in
키보드와 연결된 자바의 표준 입력 스트림  
입력되는 키를 바이트로 리턴하는 저수준 스트림  
System.in을 직접 사용하면 바이트를 문자나 숫자로 변환한느 많은 어려움이 있음

## Scanner 클래스
읽은 바이트를 문자,정수,실수,불린,문자열 등 다양한 타입으로 변환하여 리턴  
-java.util.Scanner  
객채 생성  
-키보드에 연결된 System.in 에게 키를 읽게한다

## Scanner를 이용한 키 입력
개발자가 원하는 타입 값으로 쉽게 읽을수 있음

## 식과 연산자
연산  
-주어진 식을 계산하여 결과를 얻어내는 과정

## 산술 연산자
-더하기, 빼기, 곱하기, 나누기, 나머지  
-/와 % 응용

## 증감연산
a++: a를 1증가하고 증가 전의 값 반환  
a--: a를 1감소하고 감소 전의 값 반환  
++a: a를 1증가하고 증가된 값 반환  
--a: a를 1감소하고 감소된 값 반환  

## 조건 연산
3개의 피연산자로 구성된 삼항 연산자  
-opr1?opr2:opr3  
-opr1이 true면, 연산식 결과는 opr2, false면 opr3  
if-else를 조건 연산자로 간결하게 표현 가능

## 비트 논리 연산
피 연산자의 각 비트들을 대상으로 하는 연산

## 조건문 - 단순 if문, if-else문
단순 if문
if의 관호 안에 조건식(논리형 변수나 논리 연산)  
-실행문장이 단일 문장인 경우 둘러 싸는{,} 생략가능  
if-else문  
-조건식이 true면 실행문장1,   false면 실행문장2

## switch문
switch문은 식과 case문의 값과 비교  
-case의 비교 값과 일치하면 해당 case의 실행문장 수행  
    -break를 만나면 switch문 벗어남  
-case의 비교 값과 일치하는 것이 없으면 default문 실행

## case문의 값
문자, 정수, 문자열 리터럴만 허용  
실수 리터럴은 허용되지 않음

### 3장
## 반복문
for 문  
-가장 많이 사용되는 반복문  
while 문  
    -조건식이 참인 동안 반복 실행  
do-while문  
    -조건식이 참인 동안 반복 실행  
    -작업문은 한번 반드시 실행

## break 문
반복문 하나를 즉시 벗어갈떄 사용  
-하나의 반복문만 벗어남  

## 자바 배열(Array)
인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료구조  
-배열을 이용하면 한번에 많은 메모리 공간 선언가능  
배열은 같은 타입의 데이터들이 순차적으로 저장되는 공간  
-원소 데이터들이 순차적으로 저장됨  
-인덱스를 이용하여 원소 데이터 접근  
-반복문을 이용하여 처리하기에 적합한 자료구조  
배열 인덱스  
-0부터 시작  
-인덱스는 배열의 시작 위치에서부터 데이터가 있는 상대위치

## 배열 선언 및 생성 디테일
배열 선언과 배열 생성의 두단계 필요  
배열 선언  
-배열의 이름 선언  
배열 생성  
-배열 공간 할당 받는 과정  
배열 초기화  
-배열 생성과 값 초기화

## 배열의 크기, lengh로 정리
자바 배열은 객체로 처리  
-배열 객체의 lengh 필드  

## 함수 호출시 배열 전달 비교
-c/c++의 경우 배열과 크기를 각각 전달받음  
-자바 경우 배열만 전달 받음 

## 배열과 for-each 문
배열이나 나열의 원소를 순차 접근하는데 유용한 for문  

## 3월22일 강의
ctrl+shift+p로 새로운 자바 파일을 만들수 있다  

저급언어: 컴퓨터가 이해하기 쉬운 언어 (기계어, 어셈블리어)  
고급언어: 사람이 이해하기 쉬운 언어(C/C++, Java, C#)  

소스: 프로그래밍 언어로 작성된 텍스트 파일  
컴파일: 소스파일을 컴퓨터가 이해할수 있는 기계어로 만드는 과정  

## WORA(Write Once Run Anywhere)  
-한번 작성된 코드는 모든 플랫폼에서 실행되는 자바파일  
-C/C++ 등 기존 언어가 가진 플랫폼 종속성 극복  
-네트워크에 연결된 어느 클라이언트에서나 실행  
WORA를 가능하게 하는 자바의 특징  
-바이트 코드(byte code)  
1 자바 소스를 컴파일한 목적 코드  
2 CPU에 종속적이지 않은 중립적인 코드  

## 자바 API(Applicsation Programming Interfacr)란  
-JDK에 포함된 클래스 라이브러리  

## IDE(Intergrated Development Environment)란  
-통합개발 환경  
-편집, 컴파일, 디버깅을 한번에 할수있는 통합된  개발 환경  

## 이클립스(Eclipse)  
-자바 응용 프로그램 개발을 위한 통합 개발 프로그램  
-IBM에 의해 개발된 오픈소스 프로젝트  

## 서블릿(servlet)  
웹서버에서 실행되는 자바 프로그램  

## 자바 특징  
-플랫폼 독립성  
-객체지향  
-클래스로 캡슐화  
-소스(.java)와 클래스(.class)파일  
-실행코드 배포  
-패키지  
1 서로 관련있는 여러 클래스를 패키지로 묶어 관리  
-멀티스레드  
1 여러 스레드의 동시 수행 환경 지원  
-가비지 컬렉션

## 자바의 단점  
-실시간 응용프로그램에 부적함  
-자바 프로그램은 안전  
-프로그램 작성 쉬움  
-실행속도 개선을 위한 JIT컴파일러 사용  
식별자란?  
-클래스 변수 상수 메소드 등에 붙이는 이름  
-식별자의 원칙  
1 대소문자 구별  
2 int barChart; 와 int barchart;는 서로 다르게 구별

## 자바의 데이터 타입  
-기본타입: 8개  
boolean, char, byte, short, int, long, float, double  

## 문자열  
문자열은 기본 타입이 아님  

## 변수와 선언  
-변수  
프로그램 실행 중에 값을 임시 저장하기 위한 공간  
-변수선언  
데이터 타입에서 정한 크기의 메모리 할당  

## 리터럴(literal)  
-프로그램에서 직접 표현한 값  
-정수,실수,문자,논리,문자열 리터럴이 있음  
정수 리터럴  
실수 리터럴  
-실수 타입리터럴은 double타입으로 컴파일
문자 리터럴  
-단일 인용부호('')로 문자표현  
-특수문자 리터럴은 백슬래시(\)로 시작  
## 상수
상수 선언  
-final 키워드 사용  
-선언시 초깃값 지정  
-실행중 값 변경불가  

##  var 키워드
-Java 10부터 도입  
-기존의 변수 선언 방식: 변수의 타입 반드시 지정  
-var키워드  
1 타입을 생략하고 변수 선언 가능  
2 컴파일러가 추론하여 변수 타입 결정  
3 변수 선언시 초깃값이 주어지지 않으면 컴파일 오류  
4 var은 지역 변수 선언에만 한정   

## 3월 15일 강의
내용정리